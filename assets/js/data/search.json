[ { "title": "《卓有成效的管理者》读后感", "url": "/posts/thoughts_on_Reading_Effective_Managers/", "categories": "管理, 商业", "tags": "管理, 商业", "date": "2021-11-28 22:00:00 +0800", "snippet": "1. 前言对组织负有责任，能影响组织经营成果的人，就是管理者。管理者，就必须卓有成效。卓有成效是可以学会的！2. 卓有成效的管理者大纲" }, { "title": "《向上管理》读后感", "url": "/posts/thoughts_on_Reading_Upward_Management/", "categories": "管理, 个人管理", "tags": "管理, 个人管理", "date": "2021-09-21 15:00:00 +0800", "snippet": "1. 前言在工作过程中，经常会被上司说到需要提高向上管理能力，同时自身也意识到如果提高了这方面的能力，工作成果也会有很大的提高。2. 向上管理大纲" }, { "title": "《影响力》读后感", "url": "/posts/thoughts_on_Reading_Influence/", "categories": "心理学, 影响力", "tags": "心理学, 社会心理, 营销", "date": "2021-07-25 22:00:00 +0800", "snippet": "1. 前言生活中总有一些需要说服他人或者希望防止落入他人说服力陷阱的场景，在这方面《影响力》这本书能给我们很好地指导。本文主要总结下顺从他人行为背后的6大心理秘籍：互惠、承诺和一致、社会认同、喜好、权威、稀缺。2. 互惠 给与、索取、再索取为什么起作用？人类社会从互惠原理中得到了一项重大的竞争优势，由此，他们必须要保证社会成员全部被同化，遵守并信任这一原理。如何实现？ 强加恩惠：一个人靠着硬塞给我们一些好处，就能触发我们的亏欠感 触发不平等交换：亏欠感使人感到不舒服 互惠式让步：“拒绝—后撤”术，不光刺激人们答应请求，还鼓励他们切身实践承诺，甚至叫他们自愿履行进一步的要求如何拒绝..." }, { "title": "go语言版十大排序算法", "url": "/posts/sort_algorithm/", "categories": "计算机技术, 数据结构与算法", "tags": "算法, 排序, go", "date": "2021-05-30 22:55:00 +0800", "snippet": "1. 前言排序算法是最经典的算法知识，目前共有十种排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。最近刚好在学习go语言，因此想着用go语言实现这些排序算法，纯当练练手，顺便回顾下排序算法~2. 算法实现2.1 冒泡排序算法思想： 算法过程： 在未排序序列中比较相邻的元素，如果第一个比第二个小/大，就交换它们两个，将最小/大值冒泡至最右侧 从剩余未排序元素中继续过程1 重复过程2，直到所有元素均排序完毕 代码实现：// 冒泡排序：是稳定排序，复杂度：O(n2)，空间复杂度：O(1)func bubblin..." }, { "title": "Laravel的类自动加载机制", "url": "/posts/laravel's_autoload_mechanism/", "categories": "计算机技术, php, laravel框架", "tags": "php, laravel, autoload", "date": "2021-04-10 16:00:00 +0800", "snippet": "1. 背景在PHP开发过程中，如果希望从外部引入一个class，通常会使用include和require方法，去把定义这个class的文件包含进来。include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的： require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。（推荐使用） include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。 这个在小规模开发的时候，没什么大问题；但在大型的开发项目中，这么做会产生大量的require或者include方法调用，不仅降低效率，而且使得代码难..." }, { "title": "图的5种常用的最短路算法", "url": "/posts/short_circuit_algorithms/", "categories": "计算机技术, 数据结构与算法", "tags": "算法, 图, php", "date": "2021-03-21 21:00:00 +0800", "snippet": "1. 简介图的5种常用的最短路算法为：朴素Dijkstra、 堆优化Dijkstra、Bellman-Ford、SPFA、 Floyd。以下为这5种算法的应用场景以及时间复杂度： 多源汇最短路（任意两点间的最短路） Floyd O(n^3) 单源最短路 无负边权（所有边长都为正数） 稠密图： 朴素Dijkstra O(n^2) 稀疏图： 堆优化Dijkstra O(mlogn) 有负边权 SPFA 一般O(..." } ]
